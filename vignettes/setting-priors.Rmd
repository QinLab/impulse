---
title: "Setting impulse priors"
author: "Sean R. Hackett"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Generating interpretable timecourse parameters

The impulse equations of Chechik and Koller 2009 are able to approximate many biological timecourses. One of the limitations of this equation though is that without proper constraints the impulse equation can fit a timecourse in a non-canonical fashion which limits interpretability. To enforce that the impulse equation is fit canonically priors can be used to penalize (or outright exclude) regions of parameter space.

## Impulse versus sigmoids

```{r}
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(ggplot2))
library(impulse)

sigmoid_impulse_plot <- function(timecourse_parameters) {
  
  fit_timecourse(timecourse_parameters, model = "sigmoid") %>%
    dplyr::rename(sigmoid = fit) %>%
    dplyr::left_join(fit_timecourse(timecourse_parameters, model = "impulse") %>%
                       dplyr::rename(impulse = fit), by = "time") %>%
    tidyr::gather(eqtn, level, -time) %>%
    ggplot(aes(x = time, y = level, color = eqtn)) + geom_path(size = 2) +
    theme_bw()

  }
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 0.25, v_inter = 3, v_final = -3, t_fall = 45))
```

sigmoid:
$$
v_{inter}*\frac{1}{1 + \exp(-\beta(t - t_{rise}))}
$$

implulse:
$$
\frac{1}{1 + \exp(-\beta(t - t_{rise}))} * (v_{final} + (v_{inter} - v_{final})\frac{1}{1 + \exp(\beta(t - t_{fall}))}
$$

## Constraining Vs with a Normal prior

mean = 0
sd = sd(X)

## Constraining rate

### Non-negative rates remove V interpretability

```{r}
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = -0.25, v_inter = 3, v_final = -3, t_fall = 45))
```

### Using a Gamma prior

```{r}
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 0.1, v_inter = 3, v_final = -3, t_fall = 45))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 0.5, v_inter = 3, v_final = -3, t_fall = 45))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 1, v_inter = 3, v_final = -3, t_fall = 45))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 3, v_inter = 3, v_final = -3, t_fall = 45))
```

$\beta$ should generally be between 0.1 - 1 - a fair mean would be 0.5. Fixing this the mean of $\beta \sim \Gamma$ at 0.5, we can evaluate Gamma distributions with this mean. Since the mean of a Gamma distributed random variable will be shape * scale, we can fix shape * scale at 0.5, and then vary the ratio of shape:scale to explore possible Gammas.

```{r}

betas <- seq(0, 2, by = 0.01)
shape_scale_prod <- 0.5
shape_scale_ratio <- 10^(seq(0, 2, length.out = 20))
gamma_densities <- lapply(shape_scale_ratio, function(a_shape_scale_ratio) {
  shape = sqrt(shape_scale_prod) * sqrt(a_shape_scale_ratio)
  scale = sqrt(shape_scale_prod) / sqrt(a_shape_scale_ratio)
  
  tibble::data_frame(beta = betas, shape_scale = paste(round(shape, 3), round(scale, 3), sep = "-"), density = dgamma(betas, shape = shape, scale = scale))
}) %>%
  dplyr::bind_rows()
ggplot(gamma_densities, aes(x = beta, y = density)) + facet_wrap(~ shape_scale) +
  geom_path()

```
I like shape = 2, scale = 0.25.
```{r}

qgamma(c(0.025, 0.5, 0.95), shape = 2, scale = 0.25)
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 0.06, v_inter = 3, v_final = -3, t_fall = 45))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 0.42, v_inter = 3, v_final = -3, t_fall = 45))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 1.19, v_inter = 3, v_final = -3, t_fall = 45))

```
## Constraining t_rise / t_fall
t_rise and t_fall should both be greater than 0 since we are enforcing that in the pre-induction steady state v_init = 0 (and it is removed from the sigmoid/impulse equations). We want to enforce that these coefficients are non-negative without putting a zero probability prior on these values (since this would prevent calculation of a gradient during optimization).

```{r}
sigmoid_impulse_plot(tibble::data_frame(t_rise = -25, rate = 0.25, v_inter = 3, v_final = -3, t_fall = 90))
```

A similar constraint should be applied to t_fall - t_rise. Since t_fall should be later than t_rise by definition. 

```{r}
sigmoid_impulse_plot(tibble::data_frame(t_rise = 25, rate = 0.5, v_inter = 3, v_final = -3, t_fall = 45))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 45, rate = 0.5, v_inter = 3, v_final = -3, t_fall = 25))
sigmoid_impulse_plot(tibble::data_frame(t_rise = 45, rate = 0.5, v_inter = 3, v_final = -3, t_fall = 45))
```

## Applying priors on timing coefficients
- Sample from and enforce a non-negative prior on t_rise.
- Sample from and enforce a non-negative prior on t_fall - t_rise (rather than on t_fall directly).
This prior should only be weakly informative over the positive support but exclude negative values.

```{r}
plot(dgamma(seq(0, 200, by = 0.1), shape = 2, scale = 25) ~ seq(0, 200, by = 0.1))
gamma_quantiles <- qgamma(c(0.025, 0.25, 0.5, 0.75, 0.95), shape = 2, scale = 25)
sigmoid_impulse_plot(tibble::data_frame(t_rise = gamma_quantiles[1], rate = 0.5, v_inter = 3, v_final = -3, t_fall = gamma_quantiles[1]*2))
sigmoid_impulse_plot(tibble::data_frame(t_rise = gamma_quantiles[2], rate = 0.5, v_inter = 3, v_final = -3, t_fall = gamma_quantiles[2]*2))
sigmoid_impulse_plot(tibble::data_frame(t_rise = gamma_quantiles[3], rate = 0.5, v_inter = 3, v_final = -3, t_fall = gamma_quantiles[3]*2))
sigmoid_impulse_plot(tibble::data_frame(t_rise = gamma_quantiles[4], rate = 0.5, v_inter = 3, v_final = -3, t_fall = gamma_quantiles[4]*2))
sigmoid_impulse_plot(tibble::data_frame(t_rise = gamma_quantiles[5], rate = 0.5, v_inter = 3, v_final = -3, t_fall = gamma_quantiles[5]*2))
```
